use std::path::PathBuf;
use std::fs;
use anyhow::{Result, Context};
use serde::{Deserialize, Serialize};
#[derive(Debug)]
pub struct ProjectManifest {
    pub name: String,
    pub version: String,
    pub description: Option<String>,
    pub author: Option<String>,
    pub license: Option<String>,
    pub repository: Option<String>,
    pub created: Option<String>,
}
pub fn init_project(
    name: Option<String>,
    dir: Option<PathBuf>,
    template: Option<String>,
    force: bool,
    verbose: bool,
) -> Result<()> {
    let project_dir = dir
        .unwrap_or_else(|| {
            std::env::current_dir().unwrap_or_else(|_| PathBuf::from("."))
        });
    let project_name = name
        .unwrap_or_else(|| {
            project_dir
                .file_name()
                .and_then(|n| n.to_str())
                .unwrap_or("mso-project")
                .to_string()
        });
    if verbose {
        println!("üöÄ Initializing HELIX project:");
        println!("  Name: {}", project_name);
        println!("  Directory: {}", project_dir.display());
        println!("  Template: {}", template.as_deref().unwrap_or("minimal"));
    }
    create_project_structure(&project_dir, &project_name, force)?;
    create_manifest(&project_dir, &project_name, template.as_deref())?;
    create_example_files(&project_dir, template.as_deref())?;
    register_project_globally(&project_name, &project_dir)?;
    println!("‚úÖ HELIX project '{}' initialized successfully!", project_name);
    println!("  Location: {}", project_dir.display());
    if verbose {
        println!("\nüìÅ Project structure created:");
        println!("  project.hlx - Project manifest");
        println!("  src/ - Source files directory");
        println!("  target/ - Build artifacts");
        println!("  lib/ - Dependencies");
    }
    println!("\nüìã Next steps:");
    println!("  1. cd {}", project_dir.display());
    println!("  2. Edit src/main.hlx to customize your configuration");
    println!("  3. Add dependencies with: helix add <dependency>");
    println!("  4. Build with: helix build");
    println!("  5. Run with: helix run");
    Ok(())
}
fn create_project_structure(
    project_dir: &PathBuf,
    _project_name: &str,
    force: bool,
) -> Result<()> {
    if project_dir.exists() && !force {
        let entries: Vec<_> = fs::read_dir(project_dir)
            .context("Failed to read project directory")?
            .collect::<Result<Vec<_>, _>>()
            .context("Failed to read directory entries")?;
        if !entries.is_empty() {
            return Err(
                anyhow::anyhow!(
                    "Directory '{}' is not empty. Use --force to initialize anyway.",
                    project_dir.display()
                ),
            );
        }
    }
    let src_dir = project_dir.join("src");
    let target_dir = project_dir.join("target");
    let lib_dir = project_dir.join("lib");
    fs::create_dir_all(&src_dir).context("Failed to create src directory")?;
    fs::create_dir_all(&target_dir).context("Failed to create target directory")?;
    fs::create_dir_all(&lib_dir).context("Failed to create lib directory")?;
    Ok(())
}
fn create_manifest(
    project_dir: &PathBuf,
    project_name: &str,
    template: Option<&str>,
) -> Result<()> {
    let manifest_path = project_dir.join("project.hlx");
    let current_date = chrono::Utc::now().format("%Y-%m-%d").to_string();
    let helix_content = format!(
        r#"# {} Project Configuration
# Generated by HELIX Compiler

project "{}" {{
    version = "0.1.0"
    author = "HELIX Developer"
    description = "HELIX project: {}"
    created = "{}"
    license = "MIT"
}}

# Basic agent for the project
agent "main-agent" {{
    model = "gpt-4"
    role = "Main Agent"
    temperature = 0.7
    max_tokens = 50000
    
    capabilities [
        "general-purpose"
        "task-execution"
        "problem-solving"
    ]
}}

# Basic workflow
workflow "main-workflow" {{
    trigger = "manual"
    
    step "execute" {{
        agent = "main-agent"
        task = "Execute main task"
        timeout = 30m
    }}
}}

# Development context
context "development" {{
    environment = "dev"
    debug = true
    max_tokens = 50000
    
    variables {{
        log_level = "debug"
        timeout = 60s
        retry_count = 3
    }}
}}
"#,
        project_name, project_name, project_name, current_date
    );
    fs::write(&manifest_path, helix_content).context("Failed to write project.hlx")?;
    Ok(())
}
fn create_example_files(project_dir: &PathBuf, template: Option<&str>) -> Result<()> {
    let src_dir = project_dir.join("src");
    let main_content = match template {
        Some("ai-dev") => include_str!("../../../examples/ai_development_team.hlx"),
        Some("support") => include_str!("../../../examples/customer_support.hlx"),
        Some("data-pipeline") => include_str!("../../../examples/data_pipeline.hlx"),
        Some("research") => include_str!("../../../examples/research_assistant.hlx"),
        _ => include_str!("../../../examples/minimal.hlx"),
    };
    let main_path = src_dir.join("main.hlx");
    fs::write(&main_path, main_content).context("Failed to write main.hlx")?;
    let gitignore_content = r#"# MSO Build artifacts
target/
*.hlxb

# Dependencies
lib/

# IDE files
.vscode/
.idea/
*.swp
*.swo

# OS files
.DS_Store
Thumbs.db

# Logs
*.log
"#;
    let gitignore_path = project_dir.join(".gitignore");
    fs::write(&gitignore_path, gitignore_content).context("Failed to write .gitignore")?;
    Ok(())
}
fn register_project_globally(project_name: &str, project_dir: &PathBuf) -> Result<()> {
    let home_dir = dirs::home_dir()
        .ok_or_else(|| anyhow::anyhow!("Failed to get home directory"))?;
    let baton_dir = home_dir.join(".baton");
    let projects_dir = baton_dir.join("projects");
    fs::create_dir_all(&projects_dir)
        .context("Failed to create .baton/projects directory")?;
    let project_registry = projects_dir.join(format!("{}.hlx", project_name));
    let current_time = chrono::Utc::now().to_rfc3339();
    let registry_content = format!(
        r#"# Project Registry Entry: {}
# Generated by HELIX Compiler

project "{}" {{
    name = "{}"
    path = "{}"
    created_at = "{}"
    last_accessed = "{}"
    status = "active"
}}
"#,
        project_name, project_name, project_name, project_dir.to_string_lossy(),
        current_time, current_time
    );
    fs::write(&project_registry, registry_content)
        .context("Failed to write project registry entry")?;
    Ok(())
}